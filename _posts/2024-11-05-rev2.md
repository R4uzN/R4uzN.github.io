컴퓨터에서 메모리에 데이터를 저장하는 방식인 바이트 오더링(Byte Ordering)의 

리틀 엔디언 표기법과 빅 엔디언 표기법.

2.1.

바이트 오더링은 데이터를 저장하는 방식을 말하는 것이다.

크게 두 가지가 있는데, 빅 엔디언(Big Endian)과 리틀 엔디언(Little Endian) 방식이다.

```markdown
BYTE b = 0x12;
WORD w = 0x1234;
DWORD dw = 0x12345678;
char str[] = "abcde";
```

위와 같이 총 4개의 크기가 다른 자료형이 있을 때, 각 엔디언 방식에 따라서 같은 데이터를 각각 어떤 식으로 저장하는지 보자.

| TYPE | Name | SIZE | Big Endian | Little Endian |
| --- | --- | --- | --- | --- |
| BYTE | b | 1 | [12] | [12] |
| WORD | w | 2 | [12][34] | [34][12] |
| DWORD | dw | 4 | [12][34][56][78] | [78][56][34][12] |
| char [] | str | 6 | [61][62][63][64][65][00] | [61][62][63][64][65][00] |

바이트(BYTE) 타입의 b 변수를 저장할 때는 두 방식의 차이가 없다.

2BYTE 이상의 크기를 가진 자료형을 저장할 때부터 차이가 나타난다.

빅 엔디언 방식 = 사람이 보는 방식과 동일

리틀 엔디언 = 역순

리틀 엔디언도 바이트 자체는 정상적인 순서로 저장된다.

2바이트 혹은 4바이트 자료형과 같이 멀티바이트(multi-bytes, 1바이트 이상)인 경우에만

각 바이트가 역순으로 저장되는 것이다.

또한 str 문자열은 Endian 형식에 상관없이 동일하다.

그 이유는 캐릭터(char) 배열이기 때문에 각 바이트를 하니씩 연속해서 저장한다고 생각해보면

리틀 엔디언에서도 문자열 자체는 빅 엔디언과 동일한 순서로 저장되는 것이다.

빅 엔디언은 사람이 보기에 직관적이고,

대형 UNIX 서버에 사용되는 RISC 계열의 CPU에서 많이 사용된다.

또한 네트워크 프로토콜에 빅 엔디언이 사용된다.

x86 계열의 응용 프로그램 개발자과 리버서는 애플리케이션 개발에 사용된 데이터를
네트워크로 송수신할 때 엔디언 타입을 변경해야 하기 때문에 알아두어야 할 필요가 있다.

But

Intel x86 CPU에서는 리틀 엔디언 방식을 사용한다.

따라서 Windows 계열 리버서들은 리틀 엔디언에 대해서 잘 알아야 한다.

리틀 엔디언 방식은 산술 연산과 데이터의 타입이 확장/축소될 때 더 효율적이라는 장점을 가지고 있다.

```cpp
#include "windows.h"

BYTE		b	=	0x12;
WORD	w	=	0x1234;
DWORD	dw	=	0x12345678;
char		str[]	=	"abcde";

int	main(int	argc,	char	*argv[])
{
	byte	lb	=	b;
	WORD	lw	=	w;
	DWORD	ldw	=	dw;
	char	*lstr	=	str;

	return	0;
}
```

↑ 해당 코드로 실행 파일을 생성 후  OllyDbg로 열어보자.

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/7b68f6d7-9632-4fdf-a62a-2070623c5868/76e6306a-fe4f-4506-8d9b-9b1b499ff778/image.png)

전역 변수들의 주소가 40AC40, 40AC44, 40AC48, 40AC4C 이다.

이 메모리 영역을 데이터 창에서 열어보면

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/7b68f6d7-9632-4fdf-a62a-2070623c5868/895a6910-34cc-4af3-addb-d7bb7aa8991d/image.png)

변수의 값들이 리틀 엔디언 형식으로 저장된 것을 확인할 수 있다.
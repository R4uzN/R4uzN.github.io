---
tags: [system, pwn]
---

x86-64bit

| rax (accumulator register) | 함수의 반환 값 |
| --- | --- |
| rbx (base register) | x64에서는 주된 용도 없음 |
| rcx (counter register) | 반복문의 반복 횟수, 각종 연산의 시행 횟수 |
| rdx (data register) | x64에서는 주된 용도 없음 |
| rsi (source index) | 데이터를 옮길 때 원본을 가리키는 포인터 |
| rdi (destination index) | 데이터를 옮길 때 목적지를 가리키는 포인터 |
| rsp (stack pointer) | 사용중인 스택의 위치를 가리키는 포인터 |
| rbp (stack base pointer) | 스택의 바닥을 가리키는 포인터 |

linux

코드 세그먼트 - 데이터 세그먼트 - BSS 세그먼트

힙 세그먼트 - 스택 세그먼트

자세히 이해하기 위해선 세그먼테이션 기법과 x86-64의 하드웨어 설계를 알아야 함

-코드 세그먼트는 실행 가능한 기계 코드가 위치하는 영여긍로 텍스트 세그먼트(Text Segment)라고도 불린다.

프로그램이 동작하려면 코드를 실행할 수 있어야 하므로 이 세그먼트에는 읽기 권한과 실행 권한이 부여되는데, 쓰기 권한이 있으면 공격자가 악의적인 코드를 삽입하기가 쉬워지므로, 대부분의 현재 운영체제는 이 세그먼트에 쓰기 권한을 제거한다.

-데이터 세그먼트에는  컴파일 시점에 값이 정해진 전역 변수 및 전역 상수들이 위치한다. CPU가 이 세그먼트의 데이터를 읽을 수 있어야 하므로, 읽기 권한이 부여된다.

쓰기 가능한 세그먼트/쓰기 불가능한 세그먼트로 다시 분류되는데,

쓰기 가능한 세그먼트는 전역 변수와 같이 프로그램이 실행되면서 값이 변할 수 있는 데이터들이 위치한다. 이를 data 세그먼트라고 부른다.

쓰기 불가능한 세그먼트에는 프로그램이 실행되면서 값이 변하면 안되는 데이터들이 위치한다. 전역으로 선언된 상수가 여기에 포함된다. 이런 세그먼트를 rodata(read-only-data) 세그먼트라고 부른다.

-BSS 세그먼트는 컴파일 시점에 값이 정해지지 않은 전역 변수가 위치하는 메모리  영역이다. 여기에는 개발자가 선언만 하고 초기화하지 않은 전역변수 등이 포함된다.

이 세그먼트의 메모리 영역은 프로그램이 시작될 때, 모두 0으로 값이 초기화된다.

이 세그먼트에는 읽기 권한 및 쓰기 권한이 부여된다.

-스택 세그먼트는 프로세스의 스택이 위치하는 영역이다. 함수의 인자나 지역 변수와 같은 임시 변수들이 실행중에 여기에 저장된다.

스택 세그먼트는 스택 프레임이라는 단위로 사용된다. 스택 프레임은 함수가 호출될 때 생성되고, 반환될 때 해제 된다. 그런데 프로그램의 전체 실행 흐름은 사용자의 입력을 비롯한 여러 요인에 영향을 받는다.

어떤 프로세스가 실행될 때 얼마 만큼의 스택 프레임을 사용하게 될 지를 미리 계산하는 것은 일반적으로 불가능하다.

그래서 운영체제는 프로세스를 시작할 때 작은 크기의 스택 세그먼트를 먼저 할당해주고, 부족해 질 때마다 이를 확장해준다.

스택은 ‘아래로 자란다.’

스택이 확장될 때, 기존 주소보다 낮은 주소로 확장되기 때문이다.

이 영역은 CPU가 자유롭게 값을 읽고 쓸 수 있어야 하므로, 읽기와 쓰기 권한이 부여된다.

-힙 세그먼트는 힙 데이터가 위치하는 세그먼트이다. 스택과 마찬가지로 실행중에 동적으로 할당될 수 있으며, 리눅스에서는 스택 세그먼트와 반대 방향으로 자란다.(위)

C언어에서 malloc(), calloc()등을 호출해서 할당받는 메모리가 이 세그먼트에 위치되고, 일반적으로 읽기와 쓰기 권한이 부여된다.

#어셈블리어

ISA처럼 어셈블리어의 종류도 아키텍처마다 다양.

this is x64 어셈블리어

동사에 해당하는 명령어(Opcode)와 목적어에 해당하는 피연산자(Operand)로 구성된다.

-피연산자(Operand)는 3가지 종류가 올 수 있다

1. 상수 2. 레지스터 3. 메모리

메모리 피연산자는 []으로 둘러싸인 것으로 표현되며, 앞에 크기 지정자(Size Directive) TYPE ptr이 추가될 수 있다.

여기서 타입에는 BYTE, WORD, DWORD, QWORD가 올 수 있으며, 각각 1바이트, 2바이트, 4바이트, 8바이트의 크기를 지정한다.

| **mov dst, src : src에 들어있는 값을 dst에 대입** |  |
| --- | --- |
| mov rdi, rsi | rsi의 값을 rdi에 대입 |
| mov QWORD PTR[rdi], rsi | rsi의 값을 rdi가 가리키는 주소에 대입 |
| mov QWORD PTR[rdi+8*rcx], rsi | rsi의 값을 rdi+8*rcx가 가리키는 주소에 대입 |

| **lea dst, src : src의 유효 주소(Effective Address, EA)를 dst에 저장합니다** |  |
| --- | --- |
| lea rsi, [rbx+8*rcx] | rbx+8*rcx 를 rsi에 대입 |

| **add dst, src : dst에 src의 값을 더합니다.** |  |
| --- | --- |
| add eax, 3 | eax += 3 |
| add ax, WORD PTR[rdi] | ax += *(WORD *)rdi |

| **sub dst, src: dst에서 src의 값을 뺍니다.** |  |
| --- | --- |
| sub eax, 3 | eax -= 3 |
| sub ax, WORD PTR[rdi] | ax -= *(WORD *)rdi |

| **inc op: op의 값을 1 증가시킴** |  |
| --- | --- |
| inc eax | eax += 1 |

| **dec op: op의 값을 1 감소 시킴** |  |
| --- | --- |
| dec eax | eax -= 1 |

**and dst, src: dst와 src의 비트가 모두 1이면 1, 아니면 0**

**or dst, src: dst와 src의 비트 중 하나라도 1이면 1, 아니면 0**

**xor dst, src: dst와 src의 비트가 서로 다르면 1, 같으면 0**

**not op: op의 비트 전부 반전**

비교 명령어는 두 피연산자의 값을 비교하고, 플래그를 설정한다.

cmp op1, op2: op1과 op2를 비교

test op1, op2: op1과 op2를 비교

분기 명령어는 rip를 이동시켜 실행 흐름을 바꾼다.

jmp addr: addr로 rip를 이동시킨다.

de addr: 직전에 비교한 두 피연산자가 같으면 점프 (jump if equal)

jg addr: 직전에 비교한 두 연산자 중 전자가 더 크면 점프 (jump if greater)

**#스택**

- `push val`: rsp를 8만큼 빼고, 스택의 최상단에 val을 쌓습니다.
- `pop reg`: 스택 최상단의 값을 reg에 넣고, rsp를 8만큼 더합니다.

#Opcode: 프로시저

프로시저(Procedure)는 특정 기능을 수행하는 코드 조각을 말한다. 프로시저를 사용하면 반복되는 연산을 프로시저로 대체할 수 있어서 전체 코드의 크기를 줄일 수 있다.

프로시저를 부르는 행위를 호출(Call)이라고 부르며, 프로시저에서 돌아오는 것을 반환(Return)이라고 부른다.

프로시저를 호출할 때는 프로시저를 실행하고 나서 원래의 실행 흐름으로 돌아와야 하므로, call 다음의 명령어 주소(Return Address, 반환 주소)를 스택에 저장하고 프로시저로  rip를 이동시킨다.

***RBP*** = 스택의 시작점, ***RSP*** = 스택의 꼭대기, ***RIP*** = 다음 실행할 명령어의 주소 보관함 

- `call addr`: addr의 프로시저를 호출합니다.
- `leave`: 스택 프레임을 정리합니다.
- `ret`: 호출자의 실행 흐름으로 돌아갑니다.

# **Opcode: 시스템 콜**

윈도우, 리눅스, 맥 등의 현대 운영체제는 컴퓨터 자원의 효율적인 사용을 위해, 그리고 사용자에게 편리한 경험을 제공하기 위해, 내부적으로 매우 복잡한 동작을 한다.

 운영체제는 연결된 모든 하드웨어 및 소프트웨어에 접근할 수 있으며, 이들을 제어할 수도 있다.

 그리고 해킹으로부터 이 막강한 권한을 보호하기 위해 커널 모드와 유저 모드로 권한을 나눈다.

커널 모드는 운영체제가 전체 시스템을 제어하기 위해 시스템 소프트웨어에 부여하는 권한이다. 파일시스템, 입력/출력, 네크워크 통신, 메모리 관리 등 모든 저수준의 작업은 사용자 모르게 커널 모드에서 진행된다.

유저 모드는 운영체제가 사용자에게 부여하는 권한

게임을 하는 것과 프로그래밍을 하는 것 모두 유저 모드에서 이루어진다. 리눅스에서 루트 권한으로 사용자를 추가하고, 패키지를 내려 받는 행위도 마찬가지이다. 유저 모드에서는 해킹이 발생해도, 해커가 유저 모드의 권한까지 밖에 획득하지 못하기 때문에 해커로부터 커널의 막강한 권한을 보호할 수 있다.

시스템 콜(syscall)은 유저 모드에서 커널 모드의 시스템 소프트웨어에게 어떤 동작을 요청하기 위해 사용된다, 소프트웨어 대부분은 커널의 도움이 필요

ex) 사용자가 cat flag를 실행하면 cat flag라는 파일을 읽어서 사용자의 화면에 출력해줘야 하는데, flag는 파일 시스템에 존재하므로 접근 권한이 필요하다. 따라서 커널의 도움이 필요하고, 이를 요청하는 것을 시스템 콜이라고 한다.

x64 아키텍처에서는 시스템콜을 위해 syscall 명령어가 있다. 

## **x64 syscall 테이블**

시스템 콜 테이블의 일부

| **syscall** | **rax** | **arg0 (rdi)** | **arg1 (rsi)** | **arg2 (rdx)** |
| --- | --- | --- | --- | --- |
| read | 0x00 | unsigned int fd | char *buf | size_t count |
| write | 0x01 | unsigned int fd | const char *buf | size_t count |
| open | 0x02 | const char *filename | int flags | umode_t mode |
| close | 0x03 | unsigned int fd |  |  |
| mprotect | 0x0a | unsigned long start | size_t len | unsigned long prot |
| connect | 0x2a | int sockfd | struct sockaddr * addr | int addrlen |
| execve | 0x3b | const char *filename | const char *const *argv | const char *const *envp |